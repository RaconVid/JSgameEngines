<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>gravity</title>
<script src="../basicEngines/extraFunctions1.js"></script>
<script>importJavascriptFromSrc.baseSrc="../";</script>
</head>
<body>
<script src="../basicEngines/_header.js"></script>
<script>
let gvec,agvec,curve,points,simulateStep,endLoop,scale;
window.onload=function(){
	curve=-1;
	scale=0.25;
	gvec=(vec)=>Math.Gvec(vec.map(v=>v*scale),curve);
	agvec=(mat)=>Math.aGvec(mat,curve).map(v=>v/scale);
	points=[];gvec([1,2]);
	simulateStep=function(particles=points,dt=0.5){
		const p=particles;
		let isDrawing=true, isProcessing=true;
		let avgPoint=gvec([0,0]);let len=p.length;
		for(let i=0;i<p.length;i++){
			if(isNaN(p[i][0][0][0])){len--;continue;}
		}
		for(let i=0;i<p.length;i++){
			if(isNaN(p[i][0][0][i])){continue;}
			avgPoint=avgPoint.mul(gvec(Math.scale(agvec(p[i][0]),1/len)));
		}
		avgPoint=avgPoint.inverse();
		if(isDrawing){
			Draw.clear();
			ctx.save();
			ctx.translate(...Draw.center);
		}
		for(let i=0;i<p.length;i++){
			let s=[];//displacement
			if(isProcessing){
				for(let j=0;j<p[i][2].length;j++){
					s[j]=p[i][1][j]*dt+p[i][2][j]/2*(dt**2);//s=ut+1/2*at^2
					p[i][1][j]=p[i][1][j]+p[i][2][j]*dt;//v=u+at
					p[i][2][j]=0;
				}
				p[i][0]=p[i][0].mul(gvec(s));
				p[i][0]=avgPoint.mul(p[i][0]);
			}
			if(isDrawing){
				//for(let j of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[0,1],[1,-1],[1,0],[1,1]]){
					ctx.save();
					let scale=1;
					let size=scale/2*0.5+2;//(1+Math.Gvec.len(p[i][0]));
					//ctx.translate(...Math.scaleVec2(j,scale*Math.TAU));
					let moveGvec=gvec(
						Math.dif2(Inputs.mouse.vec2,Draw.center).map((v,i)=>v/Math.hypot(...Draw.center)*8)
					);
					let coords=agvec(moveGvec.mul(p[i][0])).map(v=>v*scale);//coords.shift();
					Draw.circle(coords[0],coords[1],size,"green");
					coords.map(v=>(v/scale).toFixed(1))
					//Draw.Text({text:p[i][2].map(v=>(v/scale).toFixed(1)),x:coords[0],y:coords[1]+size,align:"center",color:"white"})();
					ctx.restore();
				//}
			}
		}
		if(isDrawing){
			Draw.line(-5,0,5,0,1,"#FFFFFFC0");
			Draw.line(0,-5,0,5,1,"#FFFFFFC0");
			ctx.restore();
		}
		if(isProcessing)for(let i=0;i<p.length;i++){
			let a=p[i];//point A
			for(let j=i+1;j<p.length;j++){
				let b=p[j];//point B
				let dif=a[0].inverse().mul(b[0]);//a->b
				let dist=Math.Gvec.len(dif,curve);
				if(isNaN(dist))continue;
				//if(dist==0)continue;
				//apply force
				let force;
				if(dist<0.6){
					let cooling=0.01;
					//let dif1=a[0].mul(gvec(Math.scaleVec2(a[1],cooling))).inverse().mul(b[0].mul(gvec(Math.scaleVec2(b[1],cooling))));
					//dist=Math.len(dif1);
					force=0.0004*(dist-0.5)/(dist*0.1)**2;
				}
				else force=0.01*(dist-0.5)/((dist+0.1)**3)/(dist+0.1);
				dif=agvec(dif);
				for(let i=0;i<a[1].length;i++){
					a[2][i]+=dif[i]*force/2;
					b[2][i]-=dif[i]*force/2;
				}
			}

		}
	}
	{
		let scales=[3,0,0];
		let dimentions=2;
		let p1=new Array(3).fill(new Array(dimentions).fill(0));
		let sin60=Math.sin(Math.TAU/6);
		let sideLen=6;
		for(let i=0;i<10;i++){
			let p=p1.map((v,i)=>v.map(v=>(Math.random()*2-1)*scales[i]));
			let x=(i/sideLen)|0,y=i%sideLen;
			p[0]=[x+(y%2)*0.5,(y*sin60)];// /(Math.abs(Math.sinh(x)))
			p[0]=gvec([x*0,0]).mul(gvec(p[0]));
			points.push(p);
		}
	}
	endLoop= window.setInterval(()=>{
		simulateStep();//alert()
	},10);
}
</script>
</body>
</html>